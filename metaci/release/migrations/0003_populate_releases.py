# -*- coding: utf-8 -*-
# Generated by Django 1.11.10 on 2018-08-15 22:48
from __future__ import unicode_literals

import logging
import re

from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.db import migrations
from django.utils.dateparse import parse_date
from github3 import login

logger = logging.getLogger(__name__)

def populate_releases(apps, schema_editor):
    Build = apps.get_model('build.Build')
    Release = apps.get_model('release.Release')

    repos = {}
    for build in Build.objects.filter(plan__role = 'release_test'):
        if build.branch.repo.id not in repos:
            repos[build.branch.repo.id] = {
                'repo': build.branch.repo,
                'tags': set(),
            }
        repos[build.branch.repo.id]['tags'].add(build.branch.name.replace('tag: ',''))
  
    github = login(settings.GITHUB_USERNAME, settings.GITHUB_PASSWORD)
    for info in repos.values():
        repo = github.repository(info['repo'].owner, info['repo'].name) 
        for release in repo.iter_releases():
            if release.tag_name in info['tags']:
                ref = repo.ref('tags/{}'.format(release.tag_name))
                rel = Release(
                    repo = info['repo'],
                    status = 'published',
                    version_name = release.name,
                    version_number = release.name,
                    git_tag = release.tag_name,
                    github_release = release.html_url,
                    release_creation_date = release.created_at,
                    created_from_commit = ref.object.sha,
                )
                sandbox_date = re.findall(
                    r'^Sandbox orgs: (20[\d][\d]-[\d][\d]-[\d][\d])', release.body
                )
                if sandbox_date:
                    rel.sandbox_push_date = parse_date(sandbox_date[0], '%Y-%m-%d')
                    
                prod_date = re.findall(
                    r'^Production orgs: (20[\d][\d]-[\d][\d]-[\d][\d])', release.body
                )
                if prod_date:
                    rel.production_push_date = parse_date(prod_date[0], '%Y-%m-%d')

                package_version_id = re.findall(r'(04t[\w]{15,18})', release.body)
                if package_version_id:
                    rel.package_version_id = package_version_id[0]

                trialforce_id = re.findall(
                    r'^(0TT[\w]{15,18})', release.body
                )
                if trialforce_id:
                    rel.trialforce_id = trialforce_id[0]

                rel.save()

def populate_build_release(apps, schema_editor):
    Build = apps.get_model('build.Build')
    Release = apps.get_model('release.Release')

    for build in Build.objects.filter(plan__role__in = ['release', 'release_test']):
        try:
            rel = Release.objects.get(repo = build.repo, git_tag = build.branch.name.replace('tag: ',''))
        except ObjectDoesNotExist:
            logger.error("Couldn't find Release for build #{}".format(build.id))
            continue
        build.release = rel
        if build.plan.role == 'release':
            build.release_relationship_type = 'manual'
        else:
            build.release_relationship_type = 'test'
        build.save()
        
class Migration(migrations.Migration):

    dependencies = [
        ('repository', '0005_repository_release_tag_regex'),
        ('release', '0002_auto_20180815_2248'),
    ]

    operations = [
        migrations.RunPython(populate_releases),
        migrations.RunPython(populate_build_release),
    ]
